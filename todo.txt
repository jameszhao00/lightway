TODO:

- there's no ambient occlusion like effect in the creases! (maybe spec power's too high?)

- don't think my understanding of MIS is correct
	- can we just * the direct value by 2?

- see if brdf sampling converged to light sampling!

- work on floating point precision issues
	- intersections
	- brdf

- think the specular issue is the direct light wi/wos aren't in zup coordsys

- Shadow rays aren't tested vs back-facing polys (i.e. set the light to be above the cornell box.)

- Implement perfect specular reflection/transmission

- Look at specular reflections (PBRT doesn't sample specular with direct light) 

- Room is warped ??

- Maybe integrate FastFormat

- Figure out a way to do rotation to shading axis (z up) without testing for <0,0,1> and <0,0,-1>

DONE:

- test Debug mode with ICC/FP:Fast
	- only b/w if optimization turned on along with fast

- see if the fireflies are caused by area light's inverse distance squared thing
	- no visible diff

- fixed: the uniform grid thing is broken (try 30 subdivisions)
	- try 3 / 7 / 11 / 13 etc... not perfectly divisible stuff and see what happens
	- fix by applying an epsilon to max t in the 'ignore intersection outside the voxel' thing


- understood - understand why we can directly add (throughput * emission) when there's a specular

- Implement Pixel Debugger

- Fixed shadow ray stuff

- Jagged edges when using uniformgrid (any acceleration structure)
	caused by using intersections outside the voxel (t > min(t_max.x, t_max.y, t_max.z))

- Check for NAN/INF in the render code
	lots of floating point errors... 

- When running the classroom scene, the thing darkens after lots of samples (even though initially it's all good). 
	Try running with 0 bounces... see what happens


- normal should never reach there with 0,0,0
	- fixed. caused by returning -1 as bool

- handling when normal is 0,0,1 or 0,0,-1
	- fixed. detect when rotation axis is 0,0,0 and manually set it to 0, 0, 01. Works because if normal is 0,0,1 or 0,0,-1 rotangle will be 0

NOTES:

- watch out when typing vec3 comparison code out. 
	- don't do n.x == 0 && n.x == 0 && n.x == 0

- be careful with shadow rays 
	If they do intersect, make sure it's in front of the desired light source

-be careful of floating point stuff
	- when testing intersections, make sure cap it with min/max T, min cos theta, etc